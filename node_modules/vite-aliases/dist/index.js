import{normalizePath as t}from"vite";import e from"consola";import s,{mkdir as i}from"node:fs/promises";import{parse as o,stringify as r}from"comment-json";import n from"fast-glob";import{existsSync as a}from"node:fs";import l from"chokidar";import{resolve as c}from"path";import{resolveModule as p}from"local-pkg";var h="vite-aliases",d={dir:"src",prefix:"@",deep:!0,depth:1,createGlobalAlias:!0,createLog:!1,logPath:"src/logs",adjustDuplicates:!1,useAbsolute:!1,useConfig:!0,useIndexes:!1,dts:!1,root:process.cwd()},f={compilerOptions:{baseUrl:".",paths:{}}};function u(t,e){return t.split(e)}function m(t){return Array.isArray(t)?t:[t]}var $=e.create({defaults:{message:`[${h}] -`}});function g(t){throw $.error(new Error(t))}async function y(t){try{const e=(await s.readFile(t,"utf-8")).toString();return $.success(`Config: ${t} successfully read!`),o(e)}catch(e){$.error(`File: ${t} was not found!`)}}var w=4;async function v(t,e,i,o=w){const n=t.replace(/^.*[\\\/]/,""),a="add"===i||"default"===i?"created":"updated";try{await s.writeFile(t,r(e,null,o)),$.success(`File: ${n} successfully ${a}`)}catch(t){$.error(`File: ${n} could not be ${a}.`),g(t)}}async function b(t){const e=t.replace(/^.*[\\\/]/,"");try{const i=(await s.readFile(t,"utf-8")).toString(),o=i.split("\n")[1];let r;if(o.startsWith("\t"))r="\t";else{const t=u(o,"").findIndex((t=>" "!==t));-1===t&&$.error("Failed to interpret indentation from file. (No indentation found)"),r=t}return $.info(`File: Interpreted indentation as (${"number"==typeof r?`${r} spaces`:"tabs"}) from file ${e} successfully`),r}catch(t){return $.error(`File: Failed to interpret indentation from ${e}.`),w}}async function j(e,s="default"){const{root:i,dir:o,dts:r,useConfig:n}=e.options;if(!n)return;const a=t(`${i}/${r?"tsconfig":"jsconfig"}.json`);try{let[t,i]=await Promise.all([b(a),y(a)]);i||(f.compilerOptions.paths={...e.paths},i=Object.assign({},f)),i.compilerOptions||(i.compilerOptions={paths:{...e.paths}});let r=i.compilerOptions.paths||{};"remove"===s&&(r=Object.fromEntries(Object.entries(r).filter((t=>Object.values(e.paths).flat().includes(t[1][0])&&t[1][0].includes(o)?t:t[1][0].includes(o)?void 0:t)))),i.compilerOptions.paths={...r,...e.paths},await v(a,i,s,t)}catch(t){g(`Cannot write Config: ${a}.`)}}async function A(e,s="normal"){const{createLog:o,logPath:r}=e.options;if(!o)return;const n=t(r),l=t(`${n}/${h}.json`),c=e.aliases;try{a(n)||await i(n,{recursive:!0}),await v(l,c,s)}catch(t){g(`Cannot create Logfolder ${n}.`)}}var O=class{constructor(e,s){this.servermode=e,this.options=Object.assign({},d,s),this.fullPath=t(c(this.options.root,this.options.dir)),this.detectTypescript(),"serve"===e&&this.observe()}options;fullPath;aliases=[];directories=new Set;paths={};addAlias(e){m(e).forEach((e=>{const s=t(e),i=u(s.replace(this.fullPath,this.options.dir),"/").filter(Boolean),o=i.slice(-1)[0];let r=`${this.options.prefix}${o}`;const n=[...new Set(i)];if(this.checkForDuplicates(s,i,n),this.aliases.some((t=>t.find===r))&&($.warn("There are duplicate Aliases generated, either fix the folderstructure or enable adjustDuplicates."),this.options.adjustDuplicates&&this.options.depth>1)){const e=i.filter((e=>!u(t(this.options.dir),"/").includes(e))).join("-");r=`${this.options.prefix}${a=e,a.trim().replace(/[-_\s]+(.)?/g,((t,e)=>e?e.toUpperCase():""))}`}var a;o===this.options.dir&&this.options.createGlobalAlias&&(r=`${this.options.prefix}`),this.directories.add(e),this.aliases.push({find:`${r}`,replacement:`${e}`});const l=this.options.useAbsolute?s:function(e,s){let i=u(t(e),"/");return i=i.slice(i.findIndex((t=>t===s)),i.length),t(`./${i.join("/")}`)}(s,this.options.dir);this.options.useIndexes?this.paths[r]=[l]:this.paths[`${r}/*`]=[`${l}/*`]}))}removeAlias(e){m(e).forEach((e=>{const s=t(e);this.directories.has(s)&&(this.directories.delete(s),this.aliases=this.aliases.filter((t=>t.replacement!=s)),this.paths=Object.fromEntries(Object.entries(this.paths).filter((t=>t[1][0].slice(0,-2)!=(this.options.useIndexes?s:`${s}/*`)))))}))}checkForDuplicates(t,e,s){if(e.length!==s.length){const s=[...e].sort().filter(((t,e,s)=>{if(s[e+1]===s[e])return t}));$.warn(`Path: '${t}' contains multiple folders with same name: ${s.toString()}.`)}}detectTypescript(){this.options.dts=!this.options.dts&&!!p(`${this.options.root}/node_modules/typescript`),$.info(this.options.dts?"TypeScript got detected.":"TypeScript is not installed, fallback to JS only.")}searched=!1;async init(){this.searched||(await async function(t){const{dir:e,root:s,deep:i,depth:o}=t.options,r=await n.sync(i?`${e}/**/*`:`${e}/*`,{ignore:["node_modules"],onlyDirectories:!0,cwd:s,deep:o,absolute:!0});r.length||$.error(new Error("No Directories could be found!")),t.addAlias(r)}(this),this.options.createGlobalAlias&&this.addAlias(this.fullPath),A(this),j(this),this.searched=!0)}observe(){l.watch(this.fullPath,{ignoreInitial:!0,depth:this.options.depth}).on("addDir",(t=>{this.addAlias(t),A(this,"add"),j(this,"add"),$.info(`Watcher added new Path: ${t}`)})).on("unlinkDir",(t=>{this.removeAlias(t),A(this,"remove"),j(this,"remove"),$.info(`Watcher removed Path: ${t}`)}))}};function F(t={}){let e;return{name:"vite-aliases",enforce:"pre",config(s,{command:i}){e=new O(i,t),e.init(),s.resolve={alias:s.resolve?.alias?[...m(s.resolve.alias),...e.aliases]:e.aliases}}}}export{F as ViteAliases};